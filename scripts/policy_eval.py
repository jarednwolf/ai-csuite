#!/usr/bin/env python3
"""
Evaluate local policy bundle (JSON DSL) against collected facts.

Inputs:
- policy/facts.json (generated by scripts/policy_input_collect.py)
- policies/merge_gates.json (default bundle; override via POLICY_BUNDLE)

Behavior:
- Deterministic evaluation; writes policy/report.json (sorted keys, newline)
- Exits non-zero on violations, unless only warns and POLICY_ALLOW_WARN_OVERRIDE=1
- POLICY_ENABLED=0 disables and exits 0.

Expression DSL operators:
- Logical: allOf, anyOf, not
- Comparators: eq, gte, lte
- Set: contains
- Variables: {"var": "path.to.field"}

"""

from __future__ import annotations

import json
import os
import sys
from pathlib import Path
from typing import Any, Dict, List, Tuple

REPO_ROOT = Path(__file__).resolve().parents[1]
FACTS_PATH = REPO_ROOT / "policy/facts.json"
REPORT_PATH = REPO_ROOT / "policy/report.json"
DEFAULT_BUNDLE = REPO_ROOT / (os.environ.get("POLICY_BUNDLE") or "policies/merge_gates.json")


def _enabled() -> bool:
    return os.getenv("POLICY_ENABLED", "1").strip() not in {"0", "false", "no"}


def _allow_warn_override() -> bool:
    return os.getenv("POLICY_ALLOW_WARN_OVERRIDE", "0").strip() in {"1", "true", "yes"}


def _read(path: Path) -> Any:
    return json.loads(path.read_text())


def _get_by_path(obj: Any, path: str) -> Any:
    cur = obj
    for part in path.split("."):
        if isinstance(cur, dict) and part in cur:
            cur = cur[part]
        else:
            return None
    return cur


def eval_expr(expr: Any, facts: Dict[str, Any]) -> bool:
    if isinstance(expr, dict):
        if "allOf" in expr:
            return all(eval_expr(e, facts) for e in expr["allOf"])
        if "anyOf" in expr:
            return any(eval_expr(e, facts) for e in expr["anyOf"])
        if "not" in expr:
            return not eval_expr(expr["not"], facts)
        if "eq" in expr:
            left, right = expr["eq"][0], expr["eq"][1]
            return _value(left, facts) == _value(right, facts)
        if "gte" in expr:
            left, right = expr["gte"][0], expr["gte"][1]
            try:
                return float(_value(left, facts)) >= float(_value(right, facts))
            except Exception:
                return False
        if "lte" in expr:
            left, right = expr["lte"][0], expr["lte"][1]
            try:
                return float(_value(left, facts)) <= float(_value(right, facts))
            except Exception:
                return False
        if "contains" in expr:
            left = _value(expr["contains"].get("left"), facts)
            right = _value(expr["contains"].get("right"), facts)
            try:
                return right in (left or [])
            except Exception:
                return False
        if "var" in expr:
            return bool(_get_by_path(facts, str(expr["var"])) )
    # literal
    return bool(expr)


def _value(node: Any, facts: Dict[str, Any]) -> Any:
    if isinstance(node, dict) and "var" in node:
        return _get_by_path(facts, str(node["var"]))
    return node


def evaluate(bundle: Dict[str, Any], facts: Dict[str, Any]) -> Dict[str, Any]:
    results: List[Dict[str, Any]] = []
    overall_block = False
    overall_warn = False
    for rule in bundle.get("rules", []):
        rid = str(rule.get("id"))
        sev = str(rule.get("severity", "block")).lower()
        expr = rule.get("expr")
        ok = bool(eval_expr(expr, facts))
        res = {"id": rid, "severity": sev, "ok": ok}
        if not ok:
            msg = _message_for_rule(rid, facts)
            if msg:
                res["message"] = msg
        results.append(res)
        if not ok and sev == "block":
            overall_block = True
        if not ok and sev == "warn":
            overall_warn = True
    status = "pass"
    if overall_block:
        status = "fail"
    elif overall_warn:
        status = "warn"
    return {
        "status": status,
        "results": sorted(results, key=lambda x: (0 if x.get("ok") else 1, x.get("severity"), x.get("id"))),
    }


def _message_for_rule(rule_id: str, facts: Dict[str, Any]) -> str:
    if rule_id == "required_statuses_green":
        req = ["ai-csuite/dor", "ai-csuite/human-approval", "ai-csuite/artifacts", "ai-csuite/preview-smoke"]
        ok = set(facts.get("statuses", {}).get("ok_contexts", []))
        missing = [c for c in req if c not in ok]
        not_green = missing  # since we only record successes here
        if missing:
            return f"Required contexts missing or not green: {', '.join(missing)}"
        return ""
    if rule_id == "license_compliant":
        v = facts.get("licenses", {}).get("violations", [])
        if v:
            return "License violations: " + "; ".join(v[:5]) + ("..." if len(v) > 5 else "")
        return ""
    if rule_id == "budget_not_blocked":
        st = facts.get("budget", {}).get("status")
        if st == "blocked":
            return "Budget is in blocked state"
        return ""
    if rule_id == "budget_warn_threshold":
        st = facts.get("budget", {}).get("status")
        if st == "warn":
            return "Budget reached warning threshold"
        return ""
    if rule_id == "dor_ready":
        dor = facts.get("dor", {})
        if not dor.get("ready"):
            miss = dor.get("missing", [])
            if miss:
                return "DoR missing: " + ", ".join(miss)
            return "DoR not ready"
        return ""
    return ""


def main(argv: List[str]) -> int:
    if not _enabled():
        print("Policies disabled via POLICY_ENABLED=0", file=sys.stderr)
        return 0
    if not FACTS_PATH.exists():
        print("facts missing; run scripts/policy_input_collect.py first", file=sys.stderr)
        return 2
    bundle_path = DEFAULT_BUNDLE
    if not bundle_path.exists():
        print(f"bundle missing at {bundle_path}", file=sys.stderr)
        return 2
    facts = _read(FACTS_PATH)
    bundle = _read(bundle_path)
    report = evaluate(bundle, facts)
    REPORT_PATH.parent.mkdir(parents=True, exist_ok=True)
    content = json.dumps(report, sort_keys=True, indent=2) + "\n"
    if REPORT_PATH.exists():
        cur = REPORT_PATH.read_text()
        if cur != content:
            REPORT_PATH.write_text(content)
    else:
        REPORT_PATH.write_text(content)

    status = report.get("status")
    if status == "fail":
        print("Policy violations (block)", file=sys.stderr)
        for r in report.get("results", []):
            if not r.get("ok"):
                sev = r.get("severity")
                print(f" - [{sev}] {r.get('id')}: {r.get('message','')}", file=sys.stderr)
        return 3
    if status == "warn":
        if _allow_warn_override():
            print("Policy warnings present, override enabled; continuing", file=sys.stderr)
            return 0
        else:
            print("Policy warnings present; set POLICY_ALLOW_WARN_OVERRIDE=1 to proceed", file=sys.stderr)
            for r in report.get("results", []):
                if not r.get("ok"):
                    sev = r.get("severity")
                    print(f" - [{sev}] {r.get('id')}: {r.get('message','')}", file=sys.stderr)
            return 4
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))


